-- migration: create flashcards schema
-- description: creates generations and flashcards tables with proper constraints, indexes, rls policies and triggers
-- affected tables: public.generations, public.flashcards
-- notes: 
--   - implements sm-2 spaced repetition algorithm fields
--   - establishes user ownership via auth.users foreign keys
--   - includes automatic updated_at timestamp management
--   - enforces data validation through check constraints

-- ==================================================================
-- 1. create generations table
-- ==================================================================
-- purpose: tracks ai-generated flashcard sessions and their metrics
-- this table stores metadata about each generation process including
-- how many cards were proposed by ai and how many were accepted
create table if not exists public.generations (
  id bigint primary key generated by default as identity,
  user_id uuid not null references auth.users(id) on delete cascade,
  generated_count integer not null,
  accepted_count integer,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- add comment to table
comment on table public.generations is 'stores metrics for ai flashcard generation sessions';

-- add comments to columns
comment on column public.generations.id is 'unique identifier for the generation record';
comment on column public.generations.user_id is 'foreign key to auth.users - the user who initiated generation';
comment on column public.generations.generated_count is 'number of flashcards proposed by ai in this session';
comment on column public.generations.accepted_count is 'number of flashcards that user accepted and saved';
comment on column public.generations.created_at is 'timestamp when the generation record was created';
comment on column public.generations.updated_at is 'timestamp of last modification (auto-updated via trigger)';

-- ==================================================================
-- 2. create flashcards table
-- ==================================================================
-- purpose: main application table storing all user flashcards with sm-2 algorithm data
-- implements spaced repetition system with interval, repetition, ease_factor, and due_date
create table if not exists public.flashcards (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  front text not null check (char_length(front) > 0 and char_length(front) <= 200),
  back text not null check (char_length(back) > 0 and char_length(back) <= 500),
  interval integer not null default 0,
  repetition integer not null default 0,
  ease_factor real not null default 2.5,
  due_date timestamptz not null default now(),
  generation_type varchar(10) not null check (generation_type in ('ai', 'manual')),
  generation_id bigint references public.generations(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- add comment to table
comment on table public.flashcards is 'stores all user flashcards with sm-2 spaced repetition data';

-- add comments to columns
comment on column public.flashcards.id is 'unique identifier for the flashcard';
comment on column public.flashcards.user_id is 'foreign key to auth.users - the flashcard owner';
comment on column public.flashcards.front is 'front side of the flashcard (question), max 200 characters';
comment on column public.flashcards.back is 'back side of the flashcard (answer), max 500 characters';
comment on column public.flashcards.interval is 'sm-2: number of days until next review';
comment on column public.flashcards.repetition is 'sm-2: count of successful consecutive reviews';
comment on column public.flashcards.ease_factor is 'sm-2: ease factor affecting interval calculation';
comment on column public.flashcards.due_date is 'date when the flashcard is next scheduled for review';
comment on column public.flashcards.generation_type is 'indicates if flashcard was created manually or by ai';
comment on column public.flashcards.generation_id is 'foreign key to generations table (null for manual cards)';
comment on column public.flashcards.created_at is 'timestamp when the flashcard was created';
comment on column public.flashcards.updated_at is 'timestamp of last modification (auto-updated via trigger)';

-- ==================================================================
-- 3. create indexes
-- ==================================================================
-- composite index for optimizing queries that fetch flashcards due for review
-- this is the primary query pattern: "get all flashcards for user X where due_date <= today"
create index if not exists idx_flashcards_user_due_date 
  on public.flashcards (user_id, due_date);

comment on index idx_flashcards_user_due_date is 'optimizes queries fetching flashcards due for review by user';

-- index for generation_id to optimize joins and lookups
create index if not exists idx_flashcards_generation_id 
  on public.flashcards (generation_id) 
  where generation_id is not null;

comment on index idx_flashcards_generation_id is 'optimizes lookups of flashcards by generation session';

-- index for user_id on generations to optimize user-based queries
create index if not exists idx_generations_user_id 
  on public.generations (user_id);

comment on index idx_generations_user_id is 'optimizes queries fetching generation history by user';

-- ==================================================================
-- 4. create updated_at trigger function
-- ==================================================================
-- purpose: automatically updates the updated_at column whenever a row is modified
-- this function will be reused for both tables via separate triggers
create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql security definer;

comment on function public.handle_updated_at() is 'automatically sets updated_at to current timestamp on row update';

-- ==================================================================
-- 5. create triggers for updated_at
-- ==================================================================
-- trigger for flashcards table
-- fires before each update operation to set updated_at to current timestamp
create trigger on_flashcards_updated
  before update on public.flashcards
  for each row
  execute function public.handle_updated_at();

-- trigger for generations table
-- fires before each update operation to set updated_at to current timestamp
create trigger on_generations_updated
  before update on public.generations
  for each row
  execute function public.handle_updated_at();

-- ==================================================================
-- 6. enable row level security
-- ==================================================================
-- enable rls on both tables to ensure users can only access their own data
alter table public.flashcards enable row level security;
alter table public.generations enable row level security;

-- ==================================================================
-- 7. create rls policies for flashcards table
-- ==================================================================
-- these policies ensure users can only perform crud operations on their own flashcards
-- policies are granular (one per operation) and separated by role (anon vs authenticated)

-- policy: authenticated users can select their own flashcards
create policy "authenticated users can select own flashcards"
  on public.flashcards
  for select
  to authenticated
  using (auth.uid() = user_id);

-- policy: authenticated users can insert their own flashcards
create policy "authenticated users can insert own flashcards"
  on public.flashcards
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- policy: authenticated users can update their own flashcards
create policy "authenticated users can update own flashcards"
  on public.flashcards
  for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- policy: authenticated users can delete their own flashcards
create policy "authenticated users can delete own flashcards"
  on public.flashcards
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- policy: anonymous users cannot select flashcards
-- note: this explicit denial ensures no anonymous access
create policy "anonymous users cannot select flashcards"
  on public.flashcards
  for select
  to anon
  using (false);

-- policy: anonymous users cannot insert flashcards
create policy "anonymous users cannot insert flashcards"
  on public.flashcards
  for insert
  to anon
  with check (false);

-- policy: anonymous users cannot update flashcards
create policy "anonymous users cannot update flashcards"
  on public.flashcards
  for update
  to anon
  using (false);

-- policy: anonymous users cannot delete flashcards
create policy "anonymous users cannot delete flashcards"
  on public.flashcards
  for delete
  to anon
  using (false);

-- ==================================================================
-- 8. create rls policies for generations table
-- ==================================================================
-- these policies ensure users can only perform crud operations on their own generation records
-- policies are granular (one per operation) and separated by role (anon vs authenticated)

-- policy: authenticated users can select their own generations
create policy "authenticated users can select own generations"
  on public.generations
  for select
  to authenticated
  using (auth.uid() = user_id);

-- policy: authenticated users can insert their own generations
create policy "authenticated users can insert own generations"
  on public.generations
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- policy: authenticated users can update their own generations
create policy "authenticated users can update own generations"
  on public.generations
  for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- policy: authenticated users can delete their own generations
create policy "authenticated users can delete own generations"
  on public.generations
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- policy: anonymous users cannot select generations
-- note: this explicit denial ensures no anonymous access
create policy "anonymous users cannot select generations"
  on public.generations
  for select
  to anon
  using (false);

-- policy: anonymous users cannot insert generations
create policy "anonymous users cannot insert generations"
  on public.generations
  for insert
  to anon
  with check (false);

-- policy: anonymous users cannot update generations
create policy "anonymous users cannot update generations"
  on public.generations
  for update
  to anon
  using (false);

-- policy: anonymous users cannot delete generations
create policy "anonymous users cannot delete generations"
  on public.generations
  for delete
  to anon
  using (false);

-- ==================================================================
-- migration complete
-- ==================================================================
-- summary:
--   - created 2 tables: generations, flashcards
--   - established foreign key relationships
--   - added check constraints for data validation
--   - created indexes for query optimization
--   - implemented automatic updated_at via triggers
--   - enabled rls with granular policies for both roles
--   - all tables are protected by user_id ownership

